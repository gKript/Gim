//
// gim_private_key.cc
//
// Gim  -  Generic Information Manager static library
// Version 1.0-0
// AsYntote - SkyMatrix
//
//  [http://www.gkript.org]
//  [http://phorus.nibbles.it/trac/gkript/milestone/Gim%201.0?by=version]
//
/*#############################################################################

	Copyright (C) 2002, 2003 
	Danilo Zannoni (AsYntote) - Corrado Tumiati (SkyMatrix)

	This file is part of Gim library.

	Gim is free software; you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation; either version 2 of the License, or
	(at your option) any later version.

	Gim is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Gim; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

#############################################################################*/
//
// Gim is developed with Anjuta version 1.2.4
//

#include "../include/gim_private_key.h"

gim_private_key_obj	* gim_key;

void	gim_private_key_obj::create( void ) {
	_gim_Uint32	systime;
	_gim_rand	mt;
	unsigned char	t[ HKEY_SIZE_BIN ];
	char	Hstr[256], t1[ HKEY_SIZE_ASC ];
	_gim_int16	i , s , Hlen=0;
	_gim_buffer	cfg=NULL , cfg1=NULL ;
	_gim_Ulong	flen=0 , flen1=0;

	if ( filled == __GIM_NO ) {
		__GIM_CLEAR( key , HKEY_SIZE_ASC , char );
		gim_identity->get();
		sprintf( Hstr , "( %s ) %s@%s on %s ,compiled on %s(%x)" , gim_alias->GetKeySTR( "me" , "nick" ) , gim_identity->Login , gim_identity->Node_name , gim_identity->Release , gim_identity->Version , gim_identity->host_id );
		Hlen = strlen( Hstr );
		systime = ( _gim_Ulong ) time ( NULL );
		char cfg2[ ( flen + flen1 + 5 ) ];
		if ( cfg )
			sprintf ( cfg2 , "%s\n" , cfg );
		if ( cfg1 )
			sprintf ( cfg2 , "%s\n%s\n" , cfg2 , cfg1 );
		mt.seed();
		for ( i=0 , s = 0  ; i < HKEY_SIZE_BIN ; i++ ) {
			t[i] =  mt.randInt(256) ^ Hstr[s];
			s == Hlen ? s = 0 : s++ ;
		}
		for ( i = 0 ; i < HKEY_SIZE_BIN ; i++ )
			snprintf( ( t1 + ( 2 * i ) ) , 3 , "%02x" , ( unsigned char ) t[i] );
		for ( i = 0 ; i < HKEY_SIZE_ASC ; i++ )
			key[i] = ( unsigned char ) t1[i];
		gim_error->set( "gim_private_key_obj::create", "A new private key generated." );
		filled = __GIM_YES;
	}
	else {
		gim_error->set( "gim_private_key_obj::create", "Key already generated." );
	}
}


void	gim_private_key_obj::write	( void ) {
	FILE	* tmpfp = NULL;
	char	tmp_kname[512];
	char	timestamp[256];
	create();
	sprintf( tmp_kname , "%s%s%s" , gim_conf->GetKeySTR( "key" , "priv_path" ) , gim_alias->GetKeySTR( "me" , "nick" ) , GIM_KEY_FILE_EXTENSION );
	tmpfp = fopen( tmp_kname , "wb" );
	if ( tmpfp ) {
		time_t	tp;
		_gim_Uint32	i;
		fprintf( tmpfp , "%s %s private key\n" , PRE_LINE_KEY , gim_alias->GetKeySTR( "me" , "nick" ) );
		time ( &tp );
		strftime ( timestamp , 256 , "%A %x %H:%M:%S" , localtime ( &tp ) );
		fprintf( tmpfp , "%s generated on %s\n" , PRE_LINE_KEY , timestamp );
		fprintf( tmpfp , "%s generated by %s-%s\n" , PRE_LINE_KEY , gim_conf->GetKeySTR( "version" , "name" ) , gim_conf->GetKeySTR( "version" , "version" ) );
		fprintf( tmpfp , "%s \n" , PRE_LINE_KEY );
		fprintf( tmpfp , "%s begin coded key -\n" , PRE_LINE_KEY );
		fprintf( tmpfp , "%s\n%s " , PRE_LINE_KEY , PRE_LINE_KEY );
		for ( i = 0 ; i < HKEY_SIZE_ASC ; i++ ) {
			fprintf( tmpfp , "%c" , key[i] );
			if ( ( ! ( (i+1) % 64 ) ) ) fprintf( tmpfp , "\n%s " , PRE_LINE_KEY );
		}
		fprintf( tmpfp , "\n" );
		fprintf( tmpfp , "%s end coded key -\n" , PRE_LINE_KEY );
		fprintf( tmpfp , "%s\n" , PRE_LINE_KEY );
		fprintf( tmpfp , "%s md5sum : %s\n" , PRE_LINE_KEY , gim_checksum->md5( (char *)key , HKEY_SIZE_ASC ) );
		fprintf( tmpfp , "%s\n" , PRE_LINE_KEY );
		fflush( tmpfp );
		fclose( tmpfp );
		gim_error->set( "gim_private_key_obj::write", "Key succesfully wrote." );
	}
	else {
		gim_error->set( GIM_ALWAYSE_VERBOSE , __GIM_YES );
		gim_error->set( GIM_ERROR_CRITICAL , "gim_private_key_obj::write" , "Cannot open the PrivKey file for writing" , __GIM_ERROR );
		gim_error->set( GIM_ALWAYSE_VERBOSE , __GIM_OFF );
	}
}


void    gim_private_key_obj::read ( void ) {
	FILE	* hand = NULL;
	char	tmp_kname[512];
	char	* line , * tmp_line;
	char	ch = 10;
	_gim_int8	count;
	_gim_Uint32	index;
	if ( gim_conf->GetKeyFLAG( "alias" , "enable" ) == __GIM_YES ) {
		__GIM_CLEAR( key , HKEY_SIZE_ASC , char );
		sprintf( tmp_kname , "%s%s%s" , gim_conf->GetKeySTR( "key" , "priv_path" ) , gim_alias->GetKeySTR( "me" , "nick" ) , GIM_KEY_FILE_EXTENSION );
		hand = fopen( tmp_kname , "rb" );
		gim_error->set( "gim_private_key_obj::read", "Key opened" );
		if ( hand != NULL ) {
			line = strdup( Lexical.get_line( hand ) );
			tmp_line = Lexical.char_filter( line , ':' );
			tmp_line = Lexical.char_filter( tmp_line , '-' );
			gim_memory->caller = __GIM_MEM_READ_KEY;
			Lexical.tokenizer( tmp_line , " \n" );
			if ( ! strcmp( Tok[1] , gim_alias->GetKeySTR( "me" , "nick" ) ) ) {		// if equal
				gim_error->set( "gim_private_key_obj::read", "Nick is correct." );
				for ( count = 0 ; count < 5 ; count++ )
					Lexical.get_line( hand );
				for ( index = 0 ; index < HKEY_SIZE_ASC ; ) {
					ch = fgetc( hand );
					if ( isxdigit( ch ) ) {
						*(key + index) = ch;
						index++;
					}
				}
				gim_error->set( "gim_private_key_obj::read", "Buffer loaded." );
				rewind( hand );
				_gim_flag	stop = __GIM_NO;
				for ( ; stop == __GIM_NO ; ) {
					line = strdup( Lexical.get_line( hand ) );
					if ( strcasestr( line , "md5sum" ) != NULL ) {
						stop = __GIM_YES;
						tmp_line = strdup( Lexical.str_offset_pre( line , 14 ) );
						Lexical.tokenizer( tmp_line , " \n" );
						if ( ! strcmp( Tok[0] , gim_checksum->md5( (char *)key , HKEY_SIZE_ASC ) ) ) {
							gim_error->set( "gim_private_key_obj::read", "Key succesfully readed and hashed." );
							filled = __GIM_YES;
						}
						else {
							gim_error->set( GIM_ERROR_CRITICAL , "gim_private_key_obj::read", "Key Unsuccesfully readed. MD5Sum is not equal" , __GIM_ERROR );
							gim_error->set( GIM_ERROR_CRITICAL , "gim_private_key_obj::read", "You must rebuild a new one" , __GIM_ERROR );
						}
					}
					if ( feof ( hand ) ) stop = __GIM_YES;
				}
				fclose( hand );
			}
			else {		// if NOT equal
				fclose( hand );
				gim_error->set( GIM_ERROR_CRITICAL , "gim_private_key_obj::read", "The nick of the private keyis not the same of the current nick." , __GIM_ERROR );
				gim_error->set( GIM_ERROR_CRITICAL , "gim_private_key_obj::read", "i rebuild the key with the correct nick" , __GIM_ERROR );
				write();
			}
		}
		else {
			gim_error->set( "gim_private_key_obj::read", "File not found. i create it." );
			write();
		}
	}
	else
		gim_error->set( "gim_private_key_obj::read", "Alias disabled. So private key too" );
}
