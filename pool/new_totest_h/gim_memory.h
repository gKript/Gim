//
// gim_memory.h
//
// Gim  -  Generic Information Manager static library
// Version 2.0-0
// AsYntote - SkyMatrix
//
//  [http://www.gkript.org]
//  [http://phorus.nibbles.it/trac/gkript/milestone/Gim%201.0?by=version]
//
/*#############################################################################

	Copyright (C) 2002, 2003 
	Danilo Zannoni (AsYntote) - Corrado Tumiati (SkyMatrix)
	and
	Adriano Zannoni (Tatti)

	This file is part of Gim library.

	Gim is free software; you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation; either version 2 of the License, or
	(at your option) any later version.

	Gim is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Gim; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

#############################################################################*/

/*!	\file		gim_memory.h
	\version	2.0-0
	\brief		Copyright (C) 2002, 2003<BR>
				Danilo Zannoni (AsYntote) - Corrado Tumiati (SkyMatrix)<BR>
				Released under the terms of the GNU General Public License v2<BR>
				[ http://gkript.org/gk_gpl_v2.php ]
*/ 		

#ifndef _GIM_MEMORY_H_
#define _GIM_MEMORY_H_

	#include "gim_base_header.h"
	#include "gim_lexical.h"
	#include "gim_identity.h"
	#include "gim_interface.h"

	#define	__GIM_KB	1024		/*!<	The value of 1 Kilo bytes	*/
	#define __GIM_MB 	1048576		/*!<	The value of 1 Mega bytes	*/
	#define __GIM_GB	1073741824	/*!<	The value of 1 Giga bytes	*/

	enum memory_status {
		__GIM_MEM_UNKNOWN = -1,
		__GIM_MEM_LOCK = 20,
		__GIM_MEM_UNLOCK = 21,
	};
	
	/*!	\struct		gim_mem_list
		\warning	\n <b>It is not possible to use directly this class.</b>
		\internal
		\brief		This struct is a member of the memory list generated by the gim_memory_obj every memory allocation.
		
	*/
	struct gim_mem_list {
			/*!	\var	_gim_Uint32		caller
				\brief	this variable one, through of the functions id defined here in this header , makes available the function who demands the memory allocation .\n
			*/
			_gim_Uint32		caller;
		
			/*!	\var	_gim_flag		hide
				\brief	It is used as flag to known if the allocation of this member is hide or not
			*/
			_gim_flag		hide;

			/*!	\var	_gim_flag		lock
				\brief	It is used as flag to known if the allocation of this member is locked or not
			*/
			_gim_flag		lock;
			
			/*!	\var	void			* data
				\brief 	The pointer to the first byte of the allocated memory
			*/
			void 			* data;
		
			/*!	\var 	_gim_Ulong		size
				\brief	The size of the allocated memory
			*/
			_gim_Ulong		size;
		
			/*! \var	gim_mem_list		* next
				\brief	A pointer to the next gim_mem_list
			*/
			gim_mem_list	* next;
	};

	#define	__GIM_MEM_OTHER					0xff000000		/*!<	The default value for gim_mem_list::caller */
	#define	__GIM_MEM_READ_KEY				0xff000002		/*!<	caller is gim_private_key_obj::read */
	#define	__GIM_MEM_PRSP_UP				0xff000009		/*!<	caller is gim_prsr_obj::Up */
	#define __GIM_MEM_PRSR_ADDSECT  		0xff000010		/*!<	caller is gim_prsr_obj::AddSection */
	#define __GIM_MEM_PRSR_ADDKEY			0xff000011		/*!<	caller is gim_prsr_obj::AddKey */
	#define __GIM_MEM_NOSTD_CONV			0xff000013		/*!<	caller is prsr_lexical_class::str_nostd_conv */
	#define __GIM_MEM_FMAN_INIT				0xff000015		/*!<	caller is gim_file_manager_obj::init */
	#define __GIM_MEM_FMAN_NEW				0xff000016		/*!<	caller is gim_file_manager_obj::new_item */
	#define __GIM_MEM_FMAN_OPEN				0xff000017		/*!<	caller is gim_file_manager_obj::open */
	#define __GIM_MEM_FOBJ_LOAD				0xff000018		/*!<	caller is gim_file_obj::load */
	#define	__GIM_MEM_FMAN_LOAD				0xff000024		/*!<	caller is gim_file_manager_obj::load */
	#define __GIM_MEM_FOBJ_LOAD_GCH 		0xff000020		/*!<	caller is gim_file_obj::load_gch */
	#define __GIM_MEM_GETID_CPU				0xff000021		/*!<	caller is gim_identity_obj::cpu */
	#define __GIM_MEM_GETID_MEM				0xff000022		/*!<	caller is gim_identity_obj::memory */
	#define __GIM_HTML_PAGE					0xff000025		/*!<	caller is gim_html_obj */
	#define	__GIM_MEM_FILE_DATA_R			0xff000026		/*!<	caller is gim_file_data_obj::read */
	#define	__GIM_MEM_GKDP_TAKE				0xff000027		/*!<	caller is gim_gkp_obj::gkdp_take */
	#define	__GIM_MEM_INTERF_DATA			0xff000028		/*!<	caller is gim_gkp_obj::gkdp_take */
	#define	__GIM_MEM_DB_MAIN				0xff000029		/*!<	caller is gim_db_obj::gim_db_obj */
	#define	__GIM_MEM_DB_TABLE				0xff000030		/*!<	caller is gim_db_obj::add_table */
	#define __GIM_MEM_DIRECTORY_FLIST_ADD	0xff000031		/*!<	caller is gim_directory_obj::add */
 	#define __GIM_MEM_DIRECTORY_ITEM		0xff000032		/*!<	caller is gim_directory_obj::add */
 	#define __GIM_LIST_ITEM					0xff000033		/*!<	caller is gim_directory_obj::add */
 	#define __GIM_GETOPT_ITEM				0xff000034		/*!<	caller is gim_directory_obj::add */
 	#define __GIM_ASCII_BUFFER				0xff000035		/*!<	caller is gim_directory_obj::add */
	

	#define __GIM_MEM_PAGE_ADD				0xff002000		/*!<	gim_memory_page_obj::add */

	#define	__ID_COMMAND_ERROR				0xffffffff		/*!<	returned in case of error from gim_memory_obj::id_to_code */

	#define __GIM_W32_OPEN_FMAP  			0xfff00001		/*!<	caller is cnc_file_manage_class::open_Fmapping */

	#define __GIM_MEM_GKP_FLIST_ADD 		0xff001000		/*!<	gim_file_list_obj::add */
	
	#define	__GIM_NOT_HIDE					2
	#define __GIM_HIDE 						1

	/*! \class 		gim_memory_obj
		\brief		This class is very useful to avoid allocated memory leak. With this class
					you write the code and Gim takes care of the memory.
		\author		Danilo Zannoni  -  asyntote@gkript.org
		\version	2.0-0
		\date		2003-2008
	*/
	class gim_memory_obj {
		public:
			/*!	\fn		void *	Alloc( size_t size )
				\brief	This method is useful in order to alloc memory holding trace.
				\param	size	The size of the memory you want to alloc\n
								\a size >= 0
				\return An handle to the allocated memory or \n
						NULL in case of error
			*/
			void *	Alloc( size_t size );

			/*!	\fn		void *	Alloc( size_t size )
				\brief	This method is useful in order to alloc memory holding trace.
				\param	size	The size of the memory you want to alloc\n
								\a size >= 0
				\return An handle to the allocated memory or \n
						NULL in case of error
			*/
			void *	Alloc_locked( size_t size );

			/*!	\fn		void *	Alloc( size_t size )
				\brief	This method is useful in order to alloc memory holding trace.
				\param	size	The size of the memory you want to alloc\n
								\a size >= 0
				\return An handle to the allocated memory or \n
						NULL in case of error
			*/
			void *	Alloc_unlocked( size_t size );

			/*!	\fn		void *	Alloc( size_t size , _gim_Uint32 code )
				\brief	This method is useful in order to alloc memory holding trace.
				\param	size	The size of the memory you want to alloc\n
								\a size >= 0
				\param	code	the id indicates the calling function.\n
				\return an handle to the allocated memory or \n
						NULL in case of some error
			*/
			void *	Alloc( size_t size , _gim_Uint32 code );
			
			/*!	\fn		void *	Alloc( size_t size , _gim_Uint32 code , _gim_flag hidden )
				\brief	This method is useful in order to alloc memory holding trace.
				\param	size	The size of the memory you want to alloc\n
								\a size >= 0
				\param	code	the id indicates the calling function.\n
				\param	hidden	When is __GIM_HIDE the allocation oparation is not logged
				\return an handle to the allocated memory or \n
						NULL in case of some error
			*/
			void *	Alloc( size_t size , _gim_Uint32 code , _gim_flag hidden );
			
			/*!	\fn		void *	Alloc( size_t size , char * id )
				\brief	This method is useful in order to alloc memory holding trace.
				\param	size	The size of the memory you want to alloc\n
								\a size >= 0
				\param	id		the id indicates the calling function.\n
								\a id != NULL
				\return an handle to the allocated memory or \n
						NULL in case of some error
			*/
			void *	Alloc( size_t size , char * id );
			
			/*!	\fn		_gim_flag	Free( void *  to_free )
				\brief	Use this method in order to free the memory allocated with gim_memory_obj::Alloc.
				\param	to_free	The pointer to the allocated memory to free\n
								\a to_free != NULL
				\return	\a __GIM_OK if the operation is succesfully terminated or
						\a __GIM_NOT_OK	if not
			*/
			_gim_flag	Free( void *  to_free );
			
			/*!	\fn		_gim_flag	Free( void *  to_free )
				\brief	Use this method in order to free the memory allocated with gim_memory_obj::Alloc.
				\param	to_free	The pointer to the allocated memory to free\n
								\a to_free != NULL
				\return	\a __GIM_OK if the operation is succesfully terminated or
						\a __GIM_NOT_OK	if not
			*/
			_gim_flag	Unlock_and_free( void *  to_free );

			/*!	\fn		_gim_flag	Free( void *  to_free )
				\brief	Use this method in order to free the memory allocated with gim_memory_obj::Alloc.
				\param	to_free	The pointer to the allocated memory to free\n
								\a to_free != NULL
				\return	\a __GIM_OK if the operation is succesfully terminated or
						\a __GIM_NOT_OK	if not
			*/
			_gim_flag	Lock( void *  to_lock );

			/*!	\fn		_gim_flag	Free( void *  to_free )
				\brief	Use this method in order to free the memory allocated with gim_memory_obj::Alloc.
				\param	to_free	The pointer to the allocated memory to free\n
								\a to_free != NULL
				\return	\a __GIM_OK if the operation is succesfully terminated or
						\a __GIM_NOT_OK	if not
			*/
			_gim_flag	Unlock( void *  to_unlock );


			/*!	\fn		_gim_flag	Free( void *  to_free )
				\brief	Use this method in order to free the memory allocated with gim_memory_obj::Alloc.
				\param	to_free	The pointer to the allocated memory to free\n
								\a to_free != NULL
				\return	\a __GIM_OK if the operation is succesfully terminated or
						\a __GIM_NOT_OK	if not
			*/
			_gim_flag	Get_lock_status( void * to_check );

			/*!	\fn		_gim_flag	Check( void *  to_check )
				\brief	Use this method to checl if the memory pointed by \a to_check was allocated with gim_memory_obj::Alloc.
				\param	to_check	The pointer to the allocated memory to free\n
									\a to_free != NULL
				\return	\a __GIM_EXIST if the memory was allocated with gim_memory_obj::Alloc or 
						\a __GIM_NOT_EXIST if not
			*/
			_gim_flag	Check( void *  to_check );
			
			char *		metric_converter( _gim_Ulong size );

			void		hide( _gim_flag flag );
			void		mem_alloc_limit( _gim_flag flag , _gim_Uint8 mlimit );
			void		set_default_lock( _gim_flag deflock );
			void		Vmem( _gim_flag flag );
			
			_gim_Uint32	Max_allocable		( void );
			_gim_Uint32	Allocated			( void );
			_gim_Uint32	Allocated_peek		( void );
			_gim_flag	Virtual_memory		( void );
			_gim_flag	Allocation_limit	( void );
			void		peek_reset			( void );

		private:
	friend	class prsr_lexical_class;
	friend	class gim_private_key_obj;
	friend	class gim_identity_obj;
	friend	class gim_obj;		
		
			void				up( void );
			void				down( void );
			_gim_Uint32			release_memory_list( void );
			_gim_Uint32			id_to_code( const char * id );
			_gim_Uint32			Memory( void );
			char *				code_to_id( _gim_Uint32 code );
			void				Memory_update( void );

			gim_mem_list		* startlist;
			gim_mem_list		* currentlist;
			gim_mem_list		* endlist;

			gim_mem_list		* freelist_start;
			gim_mem_list		* freelist_current;
			gim_mem_list		* freelist_end;

			_gim_Uint32			caller;
			_gim_Uint32			max_allocation;
			int					allocated;
			int					allocated_peek;
			volatile _gim_flag	Hide;
			volatile _gim_flag	lock;
			volatile _gim_flag	virt_mem;
			volatile _gim_flag	Alloc_limit;
			_gim_Uint16			Limit;
	
		public:
			/*! the constuctor
			*/
			inline gim_memory_obj() {
				caller		= __GIM_MEM_OTHER;
				Hide		= __GIM_YES;
				startlist 	= NULL;
				currentlist	= NULL;
				endlist		= NULL;

				freelist_start = NULL;
				freelist_current = NULL;
				freelist_end = NULL;

			};
	};
	
	/*!	\struct		gim_memory_id
		\warning	\n <b>It is not possible to use directly this struct.</b>
		\internal
		\brief		This struct is useful to convert the code memory to a memory id.
	*/	
	struct gim_memory_id {
		_gim_Uint32	code;	 
		char		id[256];
	};
	
	extern class gim_memory_obj	* gim_memory;
	
	extern struct gim_memory_id memory_id_cnc[];
	extern struct gim_memory_id memory_id_gkp[];
	extern struct gim_memory_id memory_id_command[];
	
	
	#define		MIN_PAGE_SIZE	( 1 * 1024 * 1024 * sizeof( char ) )

		/*!	\struct		gim_mem_page_list
		\warning	\n <b>It is not possible to use directly this class.</b>
		\internal
		\brief		This struct is a member of the memory page list generated by the gim_memory_page_obj every memory allocation.
		
	*/
	struct gim_mem_page_list {
			/*!	\var	void			* data
				\brief 	The pointer to the first byte of the allocated memory
			*/
			void 				* data;
		
			/*!	\var 	_gim_Ulong		size
				\brief	The size of the allocated memory
			*/
			_gim_Ulong			size;
		
			/*! \var	gim_mem_page_list	* next
				\brief	A pointer to the next gim_mem_page_list
			*/
			gim_mem_page_list	* next;
	};
	
	
	/*! \class 		gim_memory_page_obj
		\brief		
		\author		Danilo Zannoni  -  asyntote@gkript.org
		\version	2.5-0
		\date		2003-2008
	*/
	class gim_memory_page_obj {
		public:
			void *	Alloc	( size_t size );
			void	Free	( void * to_free );
		
		private:
			_gim_Uint32			release_memory_list( void );
		
			_gim_buffer			page;
			_gim_buffer			internal_page;
			
			gim_mem_page_list	* lstart;
			gim_mem_page_list	* lcurrent;
			
		public:
			gim_memory_page_obj( size_t page_size = MIN_PAGE_SIZE );
			~gim_memory_page_obj();
	};

#endif /* _GIM_MEMORY_H_ */
